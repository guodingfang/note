(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{369:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"回溯法原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回溯法原理","aria-hidden":"true"}},[t._v("#")]),t._v(" 回溯法原理")]),t._v(" "),a("p",[t._v("假设正则是 "),a("code",[t._v("/ab{1,3}c/g")]),t._v("，当目标字符串是 'abbbc' 时，就没有所谓的“回溯”。")]),t._v(" "),a("h2",{attrs:{id:"有匹配的回溯"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有匹配的回溯","aria-hidden":"true"}},[t._v("#")]),t._v(" 有匹配的回溯")]),t._v(" "),a("p",[t._v("如果目标字符串是 'abbc'，中间就有回溯。")]),t._v(" "),a("p",[a("code",[t._v("b{1,3}")]),t._v(" 已经匹配了2个字符 'b'，准备尝试第三个时，结果发现接下来的字符是 'c'，那么就认为 "),a("code",[t._v("b{1,3}")]),t._v(" 就已经匹配完毕。然后状态又回到之前的状态，最后再用子表示式 c，去匹配字符 'c'。")]),t._v(" "),a("h2",{attrs:{id:"常见的回溯形式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的回溯形式","aria-hidden":"true"}},[t._v("#")]),t._v(" 常见的回溯形式")]),t._v(" "),a("p",[t._v("正则表达式匹配字符串的这种方式，有个学名，叫回溯法。")]),t._v(" "),a("p",[t._v('回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种出发所能达到的所有"状态"，当一条路走到"尽头"的时候（不能再前进），再后退一步或若干步，从另一种可能的"状态"出发，继续搜索，直到所有的"路径"（状态）都试探过。这种不断"前进"、不断"回溯"寻找解的方法，就称为"回溯法"。')]),t._v(" "),a("h2",{attrs:{id:"贪婪量词"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#贪婪量词","aria-hidden":"true"}},[t._v("#")]),t._v(" 贪婪量词")]),t._v(" "),a("p",[a("code",[t._v("b{1,3}")]),t._v('，因其是贪婪的，尝试可能的顺序从多往少的方向去尝试。首先会尝试\'bbb\'，然后再看整个正则是否能匹配。不能匹配时，吐出一个"b"，即在"bb"的基础上，再做尝试，如果还不行，再吐出一个，再试。如果还不行，只能说明匹配失败了。')]),t._v(" "),a("p",[t._v("如果当多个贪婪量词挨着存在，并相互冲突时，此时会是怎样？")]),t._v(" "),a("p",[t._v("答案是，先下手为强！因为深度优先搜索。测试如下：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" string "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'12345'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" regex "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/(\\d{1,3})(\\d{1,3})/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nstring"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("regex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// => ["12345", "123", "45", index: 0, input: "12345", groups: undefined]')]),t._v("\n")])])]),a("p",[t._v("其中，前面的 "),a("code",[t._v("\\d{1,3}")]),t._v(' 匹配的是 "123"，后面的 '),a("code",[t._v("\\d{1,3}")]),t._v(' 匹配的是 "45"。')]),t._v(" "),a("h2",{attrs:{id:"惰性量词"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#惰性量词","aria-hidden":"true"}},[t._v("#")]),t._v(" 惰性量词")]),t._v(" "),a("p",[t._v("惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配，比如：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" string "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'12345'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" regex "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/(\\d{1,3}?)(\\d{1,3})/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nstring"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("regex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// => ["1234", "1", "234", index: 0, input: "12345", groups: undefined]')]),t._v("\n")])])]),a("p",[t._v("其中 "),a("code",[t._v("\\d{1,3}?")]),t._v(" 只能匹配到一个字符 '1'，而后面的 "),a("code",[t._v("\\d{1,3}")]),t._v("匹配了 '234'。")]),t._v(" "),a("p",[t._v("虽然惰性量词不贪，但也会有回溯现象。比如正则是："),a("code",[t._v("/^(\\d{1,3}?)(\\d{1,3})$/")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" string "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'12345'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" regex "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/^(\\d{1,3}?)(\\d{1,3})$/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nstring"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("regex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// => ["12345", "12", "345", index: 0, input: "12345", groups: undefined]')]),t._v("\n")])])]),a("h2",{attrs:{id:"分支结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分支结构","aria-hidden":"true"}},[t._v("#")]),t._v(" 分支结构")]),t._v(" "),a("p",[t._v("分支也是惰性的，比如 "),a("code",[t._v("/can|candy/")]),t._v('，去匹配字符串 "candy" 得到的结果是 "can"，因为分支会一个一个尝试，如果前面满足了，后面就不会再实验了。')]),t._v(" "),a("p",[t._v("分支结构，可能前面的子模式会形成局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试接下来的分支。这种尝试也会看成一种回溯。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" regex "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/^(?:can|candy)$/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" string "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'candy'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nstring"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("regex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// => ["candy", index: 0, input: "candy", groups: undefined]')]),t._v("\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);