
# 字符匹配模式

## 两种模糊匹配模式

如果正则表达式只能精确匹配是没有多大意义的，比如/hello/，也只能匹配字符串中的"hello"这个字符串

```js
const regex = /hello/;
console.log(regex.test('hello'));    // true
```

正则表达式之所以强大，是因为其能实现模糊匹配。

模糊匹配，有两个方向上的'模糊'：横向模糊和纵向模糊。

### 横向模糊匹配

横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况。

其实现的方式是使用量词，如：`{m,n}`，表示连续出现最少 m 次，最多 n 次。

比如：`/ab{2,5}c/` 表示匹配这样一个字符串：第一个字符是 "a"，接下来是2到5个 "b"，最后是字符 "c"：

```js
const regex = /ab{2,5}c/g;
const string = 'abc abbc abbbc abbbbc abbbbbc abbbbbbc';

console.log(string.match(regex));    // ["abbc", "abbbc", "abbbbc", "abbbbbc"]
```

> 注意：案例中用的正则表达式时 `/ab{2,5}c/g`，后面多个 `g`，它是正则表达式的一个修饰符。表示全局匹配，即在目标字符串中按顺序找到满足匹配模式的所有子串。

### 纵向模糊匹配

纵向模糊指的是，一个正则匹配的字符串，具体到某一个字符时，它可以不是某个确定的字符，可以有多种可能。

其实现方式是使用字符组。如 `[abc]`，表示字符是可以字符 "a","b","c" 中的任意一个。

比如：`/a[123]b/` 可以匹配如下的三种字符串：'a1b'，'a2b'，'a3b'：

```js
const regex = /1[123]b/g;
const string = 'a0b a1b a2b a3b a4b a5b';
console.log(string.match(regex));    //  ["a1b", "a2b", "a3b"]
```

## 字符组

需要强调的是，虽叫字符组（字符类），但只是其中一个字符。例如 `[abc]`，表示一个字符，可以是 a，b，c 之一。

### 范围表示法

如果字符组的字符特别多，可以使用范围表示法。比如 `[123456abcdefGHIJKLM]`，可写成 `[1-6a-fG-M]`。用连字符 - 来省略和简写。

因为连字符有特殊用途，那么要匹配 'a'，'-'，'z' 这三者中任意一个字符，该怎么做呢？

不能写成 `[a-z]`，因为其表示小写字符中的任意一个字符。

可以写成如下的方式：`[-az]` 或 `[az-]` 或 `[a\-z]`。即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就可以了。


### 排除字符组

纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是 'a'，'b'，'c'。

此时就是排除字符组（反义字符组）的概念。例如 `[^abc]`，表示一个除 'a'，'b'，'c' 之外的任意一个字符。字符组的第一位放^（脱字符），表示求反的概念。

### 常见的简写形式

有了字符组的概念后，一些常见的符号也就理解了。它们都是系统自带的简写形式。
* `\d` 就是 `[0-9]`：表示是一位数字。记忆方式：其英文是digit（数字）
* `\D` 就是 `[^0-9]`：表示除数字外的任意字符
* `\w` 就是 `[0-9a-zA-Z_]`：表示数字、大小写字母和下划线。w是word的简写，也称为单词字符
* `\W` 就是 `[^0-9a-zA-Z_]`：表示非单词字符
* `\s` 就是 `[ \t\v\n\r\f]`：表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母
* `\S` 就是 `[^ \t\v\n\r\f]`：表示非空白符
* `.` 就是 `[^\n\r\u2028\u2029]`：通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外

> 想要匹配任意字符：可用 `[\d\D]`、`[\w\W]`、`[\s\S]`和 `[^]` 中任何一个

## 量词

量词也称重复。掌握 `{n,m}` 的准确含义后，只需要记住一些简写形式。

简写形式：
* `{m,}`：表示至少出现m次。
* `{m}`：等价于{m,m}，表示出现m次
* `?`：等价于{0,1}，表示出现或者不出现
* `+`：等价于{1,}，表示至少出现1次
* `*`：等价于{0,}，表示出现任意次，有可能不出现

### 贪婪匹配

```js
const regex = /\d{2,5}/g;
const string = '123 1234 12345 123456';
console.log(string.match(regex));    // ["123", "1234", "12345", "12345"]
```

其中正则 `/\d{2,5}/`，表示数字连续出现2到5次。会匹配2位、3位、4位、5位的连续数字。

但是其是贪婪的，它会尽可能多的匹配。你能给我6个，我就要5个。你能给我3个，我就3要个。反正只要在能力范围内，越多越好。

### 惰性匹配

惰性匹配，就是尽可能少的匹配

```js
const regex = /\d{2,5}?/g;
const string = '123 1234 12345 123456';
console.log(string.match(regex));    // ["12", "12", "34", "12", "34", "12", "34", "56"]
```

其中/\d{2,5}?/表示，虽然2到5次都行。当2个就够的时候，就不会往下尝试了

通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下：
* `{m,n}?`
* `{m,}?`
* `??`
* `+?`
* `*?`

## 多选分支

一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一

具体形式如下：`(p1|p2|p3)`，其中p1，p2，p3是子模式，用 `|`（管道符）分割，表示其中任何之一

例如要匹配 'good' 和 'nice' 可以使用 `/good|nice/`。测试如下：

```js
const regex = /good|nice/g;
const string = 'good idea, nice try.';
console.log(string.match(regex));    // ["good", "nice"]
```

但有个事实应该注意，比如用 `/good|goodbye/`，去匹配 "goodbye" 字符串时，结果是 "good"：

```js
const regex = /good|goodbye/g;
const string = 'goodbye';
console.log(string.match(regex));    // ["good"]
```

而把正则改成 `/goodbye|good/`，结果是：

```js
const regex = /goodbye|good/g;
const string = 'goodbye';
console.log(string.match(regex));    // ["goodbye"]
```

也就是说，分支结构也是惰性的，即当前面的匹配上了，后面就不再尝试了。


